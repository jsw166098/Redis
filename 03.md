# Data persistence
-디스크 작성 방식

* AOF
* aof rewrite
* RDB
* preamble

---

## AOF

* Append Only File
* 명령이 실행될때마다 기록되는 파일/입력,수정,삭제 명령 실행될 때마다 기록되며 조회 명령은 기록되지 않는다.  -> 데이터 손실이 거의 없다.

### 명령이 실행될 때마다 모든 요청이 AOF 파일에 기록된다.

~~~
중복 -> 메모리 낭비, 리로드 비효율
~~~

* AOF에 중복되는 데이터가 존재하게 되며 파일의 크기 또한 커지게 된다. 
* 저장장치의 용량(OS 파일 사이즈 제한)을 넘어서 AOF 기능이 중단될 수 있다. 
* 이는 메모리 낭비이며 비효율적이다.
* 다시 데이터를 복구할 때 중복되는 모든 작업을 수행해야 하며 이 또한 비효율적이다. 복구 시간 또한 오래걸린다.

### AOF Rewrite

* 특정 시점에 데이터 전체를 다시 쓰는 기능 -> AOF는 계속 추가하면서 파일 사이즈가 계속 커지게 되기 때문이다. 
* 현재 데이터셋에 대한 이전 기록들은 모두 없애고 최종 데이터에 대한 로그 레코드만을 생성

### AOF 로깅 과정

데이터셋 변경 요청 발생!!

1. 해당 명령 수행후 **로그 레코드** 생성
2. 로그 레코드를 `AOF 버퍼`에 저장
3. fsync 함수로 인해 로그 레코드가 `AOF 파일`에 기록

### AOF Rewrite 동작!

1. Child process를 fork() 
2. Child process는 현재 시점의 데이터셋 내용을 새로운 AOF temp 파일에 작성
3. 동시에 Parent process는 새로운 명령을 현재 AOF 파일에도 작성 -> rewrite 작업 실패에 대한 보흠으로 데이터를 보호하기 위해서
4. Child process가 AOF temp 파일에 로그 레코드를 전부 기록하게 되면 parent process에게 종료 시그널을 보낸다. 
5. 종료 시그널을 받은 parent process는 AOF Rewrite 버퍼 안의 로그 레크드들을 새로은 AOF 파일에 기록한다. 
6. 마지막으로 temp AOF 파일의 이름을 기존의 AOF 파일의 이름으로 변경하여 기존의 파일을 대체하게 되면 AOF Rewrite 과정이 종료된다. 

---

## RDB

* 특정 간격마다 메모리에 있는 레디스 데이터 전체를 디스크에 쓴다. / 특정 시점의 메모리에 있는 데이터 전체를 바이너리 파일로 저장/ 메모리에 저장된 전체 데이터에 대하여 압축된 바이너리 형식으로 파일에 기록하는 방법
* AOF 파일보다 사이즈가 작다. -> 로딩 속도가 AOF 파일보다 빠르다. 
* 저장 시점을 정하는 redis.conf의 파라미터는 save이다. 
* 명령으로도 RDB 파일을 생성할 수 있다. -> BGSAVE, SAVE
* 일정 시간 안에 특정 횟수 이상의 데이터 삽입 및 변경이 발생하면 동작한다. 

### 로그 파일 구성

* 상단에는 RDB 버전, Redis 버전, 생성 시간, 현재 메모리 사용량에 대한 정보 기록
* 시스템 정보 기입 후 데이터 베이스 번호와 함께 각 데이터 베이스에 저장된 모든 키-값 쌍의 데이터가 기록된다. 
* 마지막 부분에는 로그 파일의 무결성을 보호하기 위한 체크썸이 기록된다. 

~~~
데이터 무결성(data integrity)
컴퓨팅 분야에서 완전한 수명 주기를 거치며 데이터의 정확성과 일관성을 유지하고 보증하는 것을 가리킨다. 

체크섬(check sum)
송신된 자료의 무결성을 보호하는 단순 방법
중복 검사의 한 형태로, 오류 정정을 통해 , 공간이나 시간 속에서 자료의 무결성을 보호하는 방법이다.
~~~

### RDB 로깅

* BGAVE
* SAVE

RDB 파일을 생성하는 자식 프로세스를 생성한다.
자식 프로세스가 스냅샷을 생성하는 동안 메인 프로세스는 사용자로부터 요청된 명령어를 수행한다. 

#### BGSAVE로 RDB 파일 생성

파일 쓰기 작업은 Child process가 생성되어 background로 실행되므로 쓰기 작업 중에도 레디스 서버는 클라이언트의 명령을 정상적으로 처리할 수 있다. 

1. child process를 folk() 한다.
2. child process는 데이터를 새 RDB temp 파일에 쓴다. -> 임시 파일(temp-pid.rdb)에 작성을 시작한다. 
3. 쓰기가 끝나면 기존 파일을 지우고, 이름을 변경한다.

##### 자식 프로세스의 RDB 로깅 과정

1. RDB 작업이 트리거 되면 자식 프로세스는 새로운 임시 RDB 로그 파일을 생성하고 Redis 정보(RDB 버전, Redis 버전)을 기록한다. 
2. 데이터셋에 저장된 엔트리 중 하나를 선택하여 데이터 압축 가능 여부를 검사한다. 
3. 엔트리 값이 압축 가능한 데이터인 경우 LZF 압축 알고리즘을 통해 압축하여 임시 RDB 파일(temp.pid.rdb)에 기록한다. 압축이 불가능한 데이터의 경우 압축하지 않고 그대로 임시 RDB 파일에 기록한다. 
4. 데이터셋에 저장된 모든 키-값 쌍에 대하여 압축 가능성을 검사한 후 기록한다. 
5. Redis에 저장된 모든 데이터가 로그 파일에 기록되면 임시 로그 파일 마지막에 체크썸을 기록한다. 
6. 마지막으로 임시 RDB 파일의 이름을 현재 RDB 로그 파일로 변경한 후 RDB 로깅 과정을 완료한다. 


#### SAVE로 RDB 파일 생성

Main process가 직접 파일쓰기를 한다. 따라서 작업이 끝날때 까지 클라이언트의 명령을 처리할 수 없다. redis는 단일 스레드 이기 때문이다.

1. Main process가 데이터를 새 RDB temp 파일에 쓴다.
2. 쓰기가 끝나면 기존 파일을 지우고, 새 파일로 교체한다.

## RDB, AOF 파일 크기 
AOF는 Redis가 수행한 명령어, 키, 값을 문자열 형식 그대로 기록된다. 그리고 모든 변경 사항에 대하여 로크 레크도를 기록한다. 이로 인하여 하나의 데이터에 대하여 다수의 로그 레코드가 존재할 수 있다. 
반면 RDB는 저장된 키와 값만 바이너리 형태로 기록된다. 또한 압축이 가능한 경우 압축하여 기록된다. 그리고 하나의 데이터에 대하여 오직 하나의 로그 레코드만 존재한다. 따라서 파일 크기느 RDB 파일 크기가 작을 수 빆에 없다.

